
	glBegin(GL_TRIANGLES);
	glVertexAttrib3f(0, 0.0f, 1.0f, 0.0f);
	glVertexAttrib3f(0, -1.0f, -1.0f, 0.0f);
	glVertexAttrib3f(0, 1.0f, -1.0f, 0.0f);
	glEnd();

	//// Przekszta�cenie macierzy modelu dla drugiego tr�jk�ta
	//model = glm::translate(model, glm::vec3(1.5f, 0.0f, 0.0f)); // Przesuni�cie
	//model = glm::rotate(model, glm::radians(45.0f), glm::vec3(0.0f, 0.0f, 1.0f)); // Obr�t
	//glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));


	glBegin(GL_TRIANGLES);
	glVertexAttrib3f(0, 0.0f, 1.0f, 0.0f);
	glVertexAttrib3f(0, 1.0f, 1.0f, -2.0f);
	glVertexAttrib3f(0, 2.0f, -1.0f, 0.0f);
	glEnd();
	
	/*
	// Rysowanie pierwszego tr�jk�ta
	glBindVertexArray(VAO);
	glDrawArrays(GL_TRIANGLES, 0, 3);

	// Przekszta�cenie macierzy modelu dla drugiego tr�jk�ta
	model = glm::translate(model, glm::vec3(1.5f, 0.0f, 0.0f)); // Przesuni�cie
	model = glm::rotate(model, glm::radians(45.0f), glm::vec3(0.0f, 0.0f, 1.0f)); // Obr�t
	glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));

	// Rysowanie drugiego tr�jk�ta
	glDrawArrays(GL_TRIANGLES, 0, 3);
	*/


		myfale = new Fale();
	myfale->Inicjuj(1);
	myfale->InicjujStrune(dwa_osrodki, 1);

	myfale->PogiezPlat();

	glutDisplayFunc(display);
	glutReshapeFunc(reshape);


	//while (true) {
	//	SetPlat(myfale->PogiezPlat(), 50, 30, 40);
	//	std::this_thread::sleep_for(std::chrono::milliseconds(100));
	//}

	#version 330 core
layout(location = 0) in vec3 position;
layout(location = 1) in vec3 normal;
out vec3 fragNormal;
out vec3 fragPosition;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
    vec3 p1 = position;
    vec3 p2 = vec3(gl_VertexID == 0 ? 1.0 : 0.0, gl_VertexID == 1 ? 1.0 : 0.0, gl_VertexID == 2 ? 1.0 : 0.0);
    vec3 p3 = vec3(gl_VertexID == 0 ? 0.0 : 1.0, gl_VertexID == 1 ? 0.0 : 1.0, gl_VertexID == 2 ? 0.0 : 1.0);

    vec3 U = p2 - p1;
    vec3 V = p3 - p1;
    vec3 calculatedNormal = normalize(cross(U, V));

    fragPosition = vec3(model * vec4(position, 1.0));
    fragNormal = mat3(transpose(inverse(model))) * calculatedNormal;
    gl_Position = projection * view * vec4(fragPosition, 1.0);
}

#version 330 core
layout(location = 0) in vec3 position;
layout(location = 1) in vec3 normal;
out vec3 fragNormal;
out vec3 fragPosition;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main() {
    fragPosition = vec3(model * vec4(position, 1.0));
    fragNormal = mat3(transpose(inverse(model))) * normal;
    gl_Position = projection * view * vec4(fragPosition, 1.0);
}
